name: Build LnOS ISO

on:
  push:
    branches: [ main, ISO ]
    paths:
      - 'archiso/**'
      - 'scripts/**'
      - '.github/workflows/build-iso.yml'
      - 'build-iso.sh'
      - 'build-arm-image.sh'
  pull_request:
    branches: [ main, ISO ]
    paths:
      - 'archiso/**'
      - 'scripts/**'
      - '.github/workflows/build-iso.yml'
      - 'build-iso.sh'
      - 'build-arm-image.sh'
  workflow_dispatch:
    inputs:
      architecture:
        description: 'Target architecture'
        required: true
        default: 'all'
        type: choice
        options:
          - 'x86_64'
          - 'aarch64'
          - 'utm'
          - 'all'

# add write permissions
permissions:
  contents: write

jobs:
  build-x86_64:
    if: ${{ github.event.inputs.architecture == 'x86_64' || github.event.inputs.architecture == 'all' || github.event.inputs.architecture == '' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build x86_64 ISO in privileged container
        run: |
          # Use Docker with full privileges and system mounts
          docker run --rm --privileged \
            --cap-add=ALL \
            --security-opt=apparmor:unconfined \
            --security-opt=seccomp=unconfined \
            -v /sys/fs/cgroup:/sys/fs/cgroup:rw \
            -v /dev:/dev \
            -v /proc:/proc \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace \
            archlinux:latest \
            bash -c "
              # Install required packages
              pacman -Syu --noconfirm
              pacman -S --noconfirm base-devel git archiso grub
              
              # Make scripts executable
              chmod +x build-iso.sh
              chmod +x archiso/airootfs/root/customize_airootfs.sh
              
              # Build the ISO
              ./build-iso.sh x86_64
            "

      - name: Upload x86_64 ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: lnos-x86_64-iso
          path: out/*.iso
          retention-days: 30

  build-aarch64:
    if: ${{ github.event.inputs.architecture == 'aarch64' || github.event.inputs.architecture == 'all' || github.event.inputs.architecture == '' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build aarch64 SD card images
        run: |
          # Build both full and minimal ARM64 SD card images
          docker run --rm --privileged \
            --cap-add=ALL \
            --security-opt=apparmor:unconfined \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace \
            archlinux:latest \
            bash -c '
              # Monitor disk space
              echo "=== DISK SPACE BEFORE INSTALL ==="
              df -h
              
              # Install minimal required tools (avoid base-devel to save space)
              pacman -Syu --noconfirm
              pacman -S --noconfirm git wget parted dosfstools e2fsprogs multipath-tools
              
              echo "=== DISK SPACE AFTER PACKAGE INSTALL ==="
              df -h
              
              # Clean up package cache to save space
              pacman -Sc --noconfirm
              
              # Additional cleanup to free more space
              rm -rf /var/cache/pacman/pkg/*
              rm -rf /tmp/*
              
              echo "=== DISK SPACE AFTER CLEANUP ==="
              df -h
              
              chmod +x build-arm-image.sh build-arm-minimal.sh
              
              # Check disk space before building images
              echo "=== DISK SPACE BEFORE IMAGE BUILD ==="
              df -h
              
              # Build minimal ARM64 SD card image first (smaller, faster)
              echo "=== BUILDING MINIMAL ARM IMAGE ==="
              ./build-arm-minimal.sh rpi4
              
              echo "=== DISK SPACE AFTER MINIMAL BUILD ==="
              df -h
              
              # Build full ARM64 SD card image
              echo "=== BUILDING FULL ARM IMAGE ==="
              ./build-arm-image.sh rpi4
              
              echo "=== DISK SPACE AFTER FULL BUILD ==="
              df -h
            '

      - name: Upload aarch64 SD card images
        uses: actions/upload-artifact@v4
        with:
          name: lnos-aarch64-sdcard
          path: out/*.img
          retention-days: 30

  build-utm:
    if: ${{ github.event.inputs.architecture == 'utm' || github.event.inputs.architecture == 'all' || github.event.inputs.architecture == '' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Apple Silicon UTM disk image
        run: |
          # Create UTM-compatible disk image with Arch Linux ARM
          sudo apt update && sudo apt install -y wget parted dosfstools e2fsprogs qemu-utils
          
          # Monitor disk space
          echo "=== DISK SPACE BEFORE INSTALL ==="
          df -h
          
          # Download Arch Linux ARM rootfs
          echo "=== DOWNLOADING ARCH LINUX ARM ==="
          wget http://os.archlinuxarm.org/os/ArchLinuxARM-aarch64-latest.tar.gz -O /tmp/archlinuxarm.tar.gz
          
          echo "=== DISK SPACE AFTER DOWNLOAD ==="
          df -h
          
          # Make scripts executable
          chmod +x scripts/LnOS-installer.sh
          
          # Create UTM-compatible disk image
          echo "=== CREATING UTM DISK IMAGE ==="
          
          # Create 4GB raw disk image for UTM (increased from 1.5GB to prevent space issues)
          dd if=/dev/zero of=lnos-utm-apple-silicon.img bs=1M count=4096
          
          # Create loop device and partition the disk
          LOOP_DEV=$(sudo losetup -f --show lnos-utm-apple-silicon.img)
          
          # Partition using GPT for UEFI boot (required for UTM on Apple Silicon)
          sudo parted ${LOOP_DEV} mklabel gpt
          sudo parted ${LOOP_DEV} mkpart ESP fat32 1MiB 513MiB
          sudo parted ${LOOP_DEV} set 1 esp on
          sudo parted ${LOOP_DEV} mkpart root ext4 513MiB 100%
          
          # Refresh partition table
          sudo partprobe ${LOOP_DEV}
          sleep 2
          
          # Format partitions
          sudo mkfs.fat -F32 ${LOOP_DEV}p1
          sudo mkfs.ext4 ${LOOP_DEV}p2
          
          # Mount partitions
          sudo mkdir -p /mnt/utm
          sudo mount ${LOOP_DEV}p2 /mnt/utm
          sudo mkdir -p /mnt/utm/boot
          sudo mount ${LOOP_DEV}p1 /mnt/utm/boot
          
          # Install base Arch Linux ARM system
          echo "=== INSTALLING BASE SYSTEM ==="
          
          # Extract Arch Linux ARM for aarch64 (already downloaded)
          sudo tar -xzf /tmp/archlinuxarm.tar.gz -C /mnt/utm
          
          # Copy LnOS files (match ARM build structure)
          sudo mkdir -p /mnt/utm/root/LnOS/scripts
          sudo cp -r scripts/pacman_packages /mnt/utm/root/LnOS/scripts/
          sudo cp scripts/LnOS-installer.sh /mnt/utm/root/LnOS/scripts/
          sudo chmod +x /mnt/utm/root/LnOS/scripts/LnOS-installer.sh
          sudo cp README.md LICENSE /mnt/utm/root/LnOS/ 2>/dev/null || true
          
          # Create the LnOS auto-start shell script for UTM (matches ARM build)
          sudo tee /mnt/utm/usr/local/bin/lnos-shell.sh << 'EOF'
          #!/bin/bash
          
          # LnOS Shell for UTM ARM64 - runs installer once then removes itself
          
          echo "=========================================="
          echo "      Welcome to LnOS UTM ARM64 Environment"
          echo "=========================================="
          echo ""
          
          # Wait a moment for system to settle
          sleep 2
          
          # Check if installer exists and run it
          if [[ -f /root/LnOS/scripts/LnOS-installer.sh ]]; then
              cd /root/LnOS/scripts
              chmod +x ./LnOS-installer.sh
              echo "Starting LnOS installer..."
              
              # Remove autostart immediately when installer starts
              rm -f /usr/local/bin/lnos-shell.sh
              chsh -s /bin/bash root
              
              # Run the installer with ARM target
              ./LnOS-installer.sh --target=arm
          else
              echo "ERROR: LnOS installer not found!"
              echo "Available files in /root/LnOS/scripts/:"
              ls -la /root/LnOS/scripts/ 2>/dev/null || echo "Directory not found"
              echo ""
              
              # Remove autostart even if installer not found
              rm -f /usr/local/bin/lnos-shell.sh
              chsh -s /bin/bash root
          fi
          
          echo ""
          echo "LnOS installer completed. Dropping to shell..."
          echo ""
          
          # Drop to bash shell
          exec /bin/bash
          EOF
          
          sudo chmod +x /mnt/utm/usr/local/bin/lnos-shell.sh
          
          # Add the custom shell to /etc/shells first
          echo "/usr/local/bin/lnos-shell.sh" | sudo tee -a /mnt/utm/etc/shells
          
          # Set the custom shell as root's default shell (auto-runs installer on boot)
          sudo chroot /mnt/utm chsh -s /usr/local/bin/lnos-shell.sh root
          
          # Configure system settings (match ARM build)
          echo "=== CONFIGURING SYSTEM SETTINGS ==="
          
          # Set default timezone
          sudo ln -sf /usr/share/zoneinfo/UTC /mnt/utm/etc/localtime
          
          # Configure pacman for ARM64 (using working Pi configuration)
          sudo tee /mnt/utm/etc/pacman.conf << 'EOF'
          [options]
          HoldPkg     = pacman glibc
          Architecture = aarch64
          CheckSpace
          ParallelDownloads = 5
          SigLevel    = DatabaseRequired
          LocalFileSigLevel = Optional
          
          [core]
          Include = /etc/pacman.d/mirrorlist
          
          [extra]
          Include = /etc/pacman.d/mirrorlist
          
          [community]
          Include = /etc/pacman.d/mirrorlist
          EOF
          
          # Create mirrorlist for Arch Linux ARM (using working Pi configuration)
          sudo tee /mnt/utm/etc/pacman.d/mirrorlist << 'EOF'
          # Arch Linux ARM mirrorlist
          
          # Primary mirrors
          Server = https://mirror.archlinuxarm.org/$arch/$repo
          Server = https://uk.mirror.archlinuxarm.org/$arch/$repo
          Server = https://us.mirror.archlinuxarm.org/$arch/$repo
          Server = https://sg.mirror.archlinuxarm.org/$arch/$repo
          EOF
          
          # Configure networking and DNS
          echo "=== CONFIGURING NETWORKING ==="
          
          # Setup DNS resolution first
          sudo tee /mnt/utm/etc/resolv.conf << 'EOF'
          nameserver 8.8.8.8
          nameserver 8.8.4.4
          nameserver 1.1.1.1
          EOF
          
          sudo chroot /mnt/utm systemctl enable systemd-networkd
          sudo chroot /mnt/utm systemctl enable systemd-resolved
          
          # Create network configuration for UTM
          sudo mkdir -p /mnt/utm/etc/systemd/network
          sudo tee /mnt/utm/etc/systemd/network/20-wired.network << 'EOF'
          [Match]
          Name=*
          
          [Network]
          DHCP=yes
          DNS=8.8.8.8
          DNS=8.8.4.4
          EOF
          
          # Mount necessary filesystems for chroot
          sudo mount --bind /dev /mnt/utm/dev
          sudo mount --bind /proc /mnt/utm/proc
          sudo mount --bind /sys /mnt/utm/sys
          
          # Copy host DNS resolution into chroot for network access
          sudo cp /etc/resolv.conf /mnt/utm/etc/resolv.conf
          
          # Initialize pacman keyring (essential only)
          sudo chroot /mnt/utm pacman-key --init
          sudo chroot /mnt/utm pacman-key --populate archlinuxarm
          
          # Install Linux kernel and essential packages
          echo "=== INSTALLING LINUX KERNEL ==="
          sudo chroot /mnt/utm pacman -S --noconfirm linux linux-firmware base base-devel
          
          # Install GRUB ARM64 EFI bootloader
          echo "=== INSTALLING ARM64 EFI BOOTLOADER ==="
          
          # Install GRUB for ARM64 EFI
          sudo chroot /mnt/utm pacman -S --noconfirm grub efibootmgr
          
          # Install GRUB to EFI system partition
          sudo chroot /mnt/utm grub-install --target=arm64-efi --efi-directory=/boot --bootloader-id=LnOS --removable
          
          # Create custom GRUB configuration for auto-boot
          sudo tee /mnt/utm/etc/default/grub << 'EOF'
          GRUB_DEFAULT=0
          GRUB_TIMEOUT=5
          GRUB_TIMEOUT_STYLE=menu
          GRUB_DISTRIBUTOR="LnOS"
          GRUB_CMDLINE_LINUX_DEFAULT="quiet"
          GRUB_CMDLINE_LINUX=""
          GRUB_PRELOAD_MODULES="part_gpt part_msdos"
          GRUB_TERMINAL_INPUT=console
          GRUB_TERMINAL_OUTPUT=console
          GRUB_GFXMODE=auto
          GRUB_GFXPAYLOAD_LINUX=keep
          EOF
          
          # Generate GRUB configuration
          sudo chroot /mnt/utm grub-mkconfig -o /boot/grub/grub.cfg
          
          # Cleanup chroot filesystems (with proper process cleanup)
          echo "=== CLEANING UP CHROOT ==="
          
          # Force kill any processes that might be keeping mounts busy
          sudo fuser -km /mnt/utm 2>/dev/null || true
          sleep 2
          
          # Unmount chroot filesystems in reverse order with lazy unmount as fallback
          sudo umount /mnt/utm/sys 2>/dev/null || sudo umount -l /mnt/utm/sys 2>/dev/null || true
          sudo umount /mnt/utm/proc 2>/dev/null || sudo umount -l /mnt/utm/proc 2>/dev/null || true
          sudo umount /mnt/utm/dev 2>/dev/null || sudo umount -l /mnt/utm/dev 2>/dev/null || true
          
          # Create fstab
          BOOT_UUID=$(sudo blkid -s UUID -o value ${LOOP_DEV}p1)
          ROOT_UUID=$(sudo blkid -s UUID -o value ${LOOP_DEV}p2)
          
          sudo tee /mnt/utm/etc/fstab << EOF
          UUID=${ROOT_UUID} / ext4 defaults 0 1
          UUID=${BOOT_UUID} /boot vfat defaults 0 2
          EOF
          
          # Final cleanup - force kill any remaining processes
          echo "=== FINAL CLEANUP ==="
          sudo fuser -km /mnt/utm/ 2>/dev/null || true
          sleep 3
          
          # Unmount in proper order with multiple attempts
          echo "Unmounting boot partition..."
          sudo umount /mnt/utm/boot 2>/dev/null || sudo umount -l /mnt/utm/boot 2>/dev/null || true
          
          echo "Unmounting root partition..."
          sudo umount /mnt/utm 2>/dev/null || sudo umount -l /mnt/utm 2>/dev/null || true
          
          echo "Detaching loop device..."
          sudo losetup -d ${LOOP_DEV} 2>/dev/null || true
          
          # Verify cleanup
          echo "Verifying cleanup..."
          sudo losetup -l | grep ${LOOP_DEV} || echo "Loop device successfully detached"
          
          # Create output directory
          mkdir -p out
          mv lnos-utm-apple-silicon.img out/
          
          echo "=== UTM IMAGE BUILD COMPLETE ==="
          ls -lh out/
          df -h

      - name: Upload Apple Silicon UTM image
        uses: actions/upload-artifact@v4
        with:
          name: lnos-utm-apple-silicon
          path: out/*.img
          retention-days: 30

  create-release:
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/ISO') && github.event_name == 'push'
    needs: [build-x86_64, build-aarch64, build-utm]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download x86_64 ISO
        uses: actions/download-artifact@v4
        with:
          name: lnos-x86_64-iso
          path: ./isos/

      - name: Download aarch64 SD card image
        uses: actions/download-artifact@v4
        with:
          name: lnos-aarch64-sdcard
          path: ./isos/

      - name: Download Apple Silicon UTM image
        uses: actions/download-artifact@v4
        with:
          name: lnos-utm-apple-silicon
          path: ./isos/

      - name: Check file sizes for compression decision
        run: |
          cd ./isos/
          
          echo "=== CHECKING FILE SIZES ==="
          
          # Check ISO files
          for iso in *.iso; do
            if [ -f "$iso" ]; then
              size_mb=$(du -m "$iso" | cut -f1)
              size_human=$(du -h "$iso" | cut -f1)
              echo "ISO: $(basename "$iso")"
              echo "Size: ${size_human} (${size_mb} MB)"
              
              if [[ $size_mb -lt 1000 ]]; then
                echo "‚úÖ Under 1GB - no compression needed!"
                echo "Keeping $iso uncompressed"
              else
                echo "‚ùå Over 1GB - compressing with XZ"
                echo "Compressing $iso..."
                xz -9 -T 0 "$iso"
                echo "Compressed $(basename "$iso").xz"
              fi
              echo ""
            fi
          done
          
          # Check IMG files  
          for img in *.img; do
            if [ -f "$img" ]; then
              size_mb=$(du -m "$img" | cut -f1)
              size_human=$(du -h "$img" | cut -f1)
              echo "IMG: $(basename "$img")"
              echo "Size: ${size_human} (${size_mb} MB)"
              
              if [[ $size_mb -lt 1000 ]]; then
                echo "‚úÖ Under 1GB - no compression needed!"
                echo "Keeping $img uncompressed"
              else
                echo "‚ùå Over 1GB - compressing with XZ"
                echo "Compressing $img..."
                xz -9 -T 0 "$img"
                echo "Compressed $(basename "$img").xz"
              fi
              echo ""
            fi
          done
          
          echo "=== FINAL FILES ==="
          ls -lh

      - name: Sign release files with GPG
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/ISO'
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          cd ./isos/
          
          echo "üîê Signing release files with GPG..."
          
          # Import the private key
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          
          # Get key ID for verification
          KEY_ID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5}' | head -1)
          echo "üìã Using GPG key: $KEY_ID"
          
          # Sign all release files
          for file in *.iso *.img *.xz; do
            if [ -f "$file" ]; then
              echo "üîè Signing: $file"
              
              # Create detached ASCII-armored signature
              gpg --batch --yes \
                  --pinentry-mode loopback \
                  --passphrase "$GPG_PASSPHRASE" \
                  --local-user "$KEY_ID" \
                  --detach-sign \
                  --armor \
                  --output "${file}.asc" \
                  "$file"
              
              if [ -f "${file}.asc" ]; then
                echo "‚úÖ Successfully signed: $file -> ${file}.asc"
                echo "üìù Signature size: $(wc -c < "${file}.asc") bytes"
              else
                echo "‚ùå Failed to sign: $file"
              fi
            fi
          done
          
          echo ""
          echo "=== SIGNED FILES ==="
          ls -lh *.asc 2>/dev/null || echo "No signature files found"
          
          echo ""
          echo "=== GPG KEY INFO ==="
          gpg --list-keys "$KEY_ID" || echo "Key info not available"

      - name: Generate release tag
        id: tag
        run: |
          TAG="v$(date +'%Y.%m.%d')-$(git rev-parse --short HEAD)"
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: LnOS Release ${{ steps.tag.outputs.tag }}
          body: |
            ## LnOS Custom Arch Linux Distribution
            
            ![GPG Signed](https://img.shields.io/badge/GPG-Signed-brightgreen?style=for-the-badge&logo=gnupg)
            ![Security Verified](https://img.shields.io/badge/Security-Verified-blue?style=for-the-badge&logo=shield)
            ![Integrity Guaranteed](https://img.shields.io/badge/Integrity-Guaranteed-orange?style=for-the-badge&logo=checkmarx)
            
            **üîí This release is cryptographically signed for authenticity and integrity**
            
            This release contains custom minimal Arch Linux images with the LnOS installer.
            
            ### Features:
            - **Cryptographically signed** with GPG (Key: `9486759312876AD7`)
            - Minimal Arch Linux base system
            - Interactive package selection
            - Desktop environment choices (GNOME, KDE, Hyprland, DWM, TTY)
            - CSE and Custom installation profiles
            - Automated partitioning and installation
            
            ### Files Included:
            - **x86_64 ISO/IMG**: For VMs, Intel/AMD computers, and USB boot
            - **ARM64 IMG**: SD card image for Raspberry Pi 4 and ARM64 devices
            - **UTM IMG**: Apple Silicon VM image for UTM on macOS
            - **Digital Signatures**: `.asc` files for verifying authenticity
            
            **Note**: Large files (>1GB) are compressed with XZ to stay under GitHub's 2GB limit. Files under 1GB are uncompressed and ready to use.
            
            ### üõ°Ô∏è Security & Digital Signature Verification:
            
            > ‚ö†Ô∏è **IMPORTANT**: Always verify file signatures before use! All release files are digitally signed with GPG.
            
            **GPG Key Information:**
            - **Key ID**: `9486759312876AD7`
            - **Fingerprint**: `FF3B 2203 9FA1 CBC0 72E5 8967 9486 7593 1287 6AD7`
            - **Owner**: LnOS Development Team
            
            **Verification Methods:**
            ```bash
            # Quick verification (auto-imports key)
            curl -fsSL https://raw.githubusercontent.com/uta-lug-nuts/LnOS/main/scripts/verify-signature.sh | bash -s -- <filename>
            
            # Manual verification
            curl -fsSL https://raw.githubusercontent.com/uta-lug-nuts/LnOS/main/keys/lnos-public-key.asc | gpg --import
            gpg --verify <filename>.asc <filename>
            ```
            
            ### Checksums:
            ```
            $(cd isos && sha256sum * 2>/dev/null || echo "Checksums will be calculated...")
            ```
          files: ./isos/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
