name: Build LnOS ISO

on:
  push:
    branches: [ main, ISO ]
    paths:
      - 'archiso/**'
      - 'scripts/**'
      - '.github/workflows/build-iso.yml'
      - 'build-iso.sh'
      - 'build-arm-image.sh'
  pull_request:
    branches: [ main, ISO ]
    paths:
      - 'archiso/**'
      - 'scripts/**'
      - '.github/workflows/build-iso.yml'
      - 'build-iso.sh'
      - 'build-arm-image.sh'
  workflow_dispatch:
    inputs:
      architecture:
        description: 'Target architecture'
        required: true
        default: 'both'
        type: choice
        options:
          - 'x86_64'
          - 'aarch64'
          - 'both'

# add write permissions
permissions:
  contents: write

jobs:
  build-x86_64:
    if: ${{ github.event.inputs.architecture == 'x86_64' || github.event.inputs.architecture == 'both' || github.event.inputs.architecture == '' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build x86_64 ISO in privileged container
        run: |
          # Use Docker with full privileges and system mounts
          docker run --rm --privileged \
            --cap-add=ALL \
            --security-opt=apparmor:unconfined \
            --security-opt=seccomp=unconfined \
            -v /sys/fs/cgroup:/sys/fs/cgroup:rw \
            -v /dev:/dev \
            -v /proc:/proc \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace \
            archlinux:latest \
            bash -c "
              # Install required packages
              pacman -Syu --noconfirm
              pacman -S --noconfirm base-devel git archiso grub
              
              # Make scripts executable
              chmod +x build-iso.sh
              chmod +x archiso/airootfs/root/customize_airootfs.sh
              
              # Build the ISO
              ./build-iso.sh x86_64
            "

      - name: Upload x86_64 ISO artifact
        uses: actions/upload-artifact@v4
        with:
          name: lnos-x86_64-iso
          path: out/*.iso
          retention-days: 30

  build-aarch64:
    if: ${{ github.event.inputs.architecture == 'aarch64' || github.event.inputs.architecture == 'both' || github.event.inputs.architecture == '' }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build aarch64 SD card images
        run: |
          # Build both full and minimal ARM64 SD card images
          docker run --rm --privileged \
            --cap-add=ALL \
            --security-opt=apparmor:unconfined \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace \
            archlinux:latest \
            bash -c "
              # Function to check disk space and fail if too low
              check_disk_space() {
                local min_space_gb=5
                local available_gb=$(df -BG / | awk 'NR==2 {print $4}' | sed 's/G//')
                echo "Available disk space: ${available_gb}GB"
                if [ "$available_gb" -lt "$min_space_gb" ]; then
                  echo "ERROR: Insufficient disk space! Only ${available_gb}GB available, need at least ${min_space_gb}GB"
                  exit 1
                fi
              }
              
              # Monitor disk space
              echo '=== DISK SPACE BEFORE INSTALL ==='
              df -h
              check_disk_space
              
              # Install minimal required tools (avoid base-devel to save space)
              pacman -Syu --noconfirm
              pacman -S --noconfirm git wget parted dosfstools e2fsprogs multipath-tools
              
              echo '=== DISK SPACE AFTER PACKAGE INSTALL ==='
              df -h
              check_disk_space
              
              # Clean up package cache to save space
              pacman -Sc --noconfirm
              
              # Additional cleanup to free more space
              rm -rf /var/cache/pacman/pkg/*
              rm -rf /tmp/*
              
              echo '=== DISK SPACE AFTER CLEANUP ==='
              df -h
              check_disk_space
              
              chmod +x build-arm-image.sh build-arm-minimal.sh
              
              # Check disk space before building images
              echo '=== DISK SPACE BEFORE IMAGE BUILD ==='
              df -h
              check_disk_space
              
              # Build minimal ARM64 SD card image first (smaller, faster)
              echo '=== BUILDING MINIMAL ARM IMAGE ==='
              ./build-arm-minimal.sh rpi4
              
              echo '=== DISK SPACE AFTER MINIMAL BUILD ==='
              df -h
              check_disk_space
              
              # Build full ARM64 SD card image
              echo '=== BUILDING FULL ARM IMAGE ==='
              ./build-arm-image.sh rpi4
              
              echo '=== DISK SPACE AFTER FULL BUILD ==='
              df -h
            "

      - name: Upload aarch64 SD card images
        uses: actions/upload-artifact@v4
        with:
          name: lnos-aarch64-sdcard
          path: out/*.img
          retention-days: 30

  create-release:
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/ISO') && github.event_name == 'push'
    needs: [build-x86_64, build-aarch64]
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download x86_64 ISO
        uses: actions/download-artifact@v4
        with:
          name: lnos-x86_64-iso
          path: ./isos/

      - name: Download aarch64 SD card image
        uses: actions/download-artifact@v4
        with:
          name: lnos-aarch64-sdcard
          path: ./isos/

      - name: Check file sizes for compression decision
        run: |
          cd ./isos/
          
          echo "=== CHECKING FILE SIZES ==="
          
          # Check ISO files
          for iso in *.iso; do
            if [ -f "$iso" ]; then
              size_mb=$(du -m "$iso" | cut -f1)
              size_human=$(du -h "$iso" | cut -f1)
              echo "ISO: $(basename "$iso")"
              echo "Size: ${size_human} (${size_mb} MB)"
              
              if [[ $size_mb -lt 1000 ]]; then
                echo "‚úÖ Under 1GB - no compression needed!"
                echo "Keeping $iso uncompressed"
              else
                echo "‚ùå Over 1GB - compressing with XZ"
                echo "Compressing $iso..."
                xz -9 -T 0 "$iso"
                echo "Compressed $(basename "$iso").xz"
              fi
              echo ""
            fi
          done
          
          # Check IMG files  
          for img in *.img; do
            if [ -f "$img" ]; then
              size_mb=$(du -m "$img" | cut -f1)
              size_human=$(du -h "$img" | cut -f1)
              echo "IMG: $(basename "$img")"
              echo "Size: ${size_human} (${size_mb} MB)"
              
              if [[ $size_mb -lt 1000 ]]; then
                echo "‚úÖ Under 1GB - no compression needed!"
                echo "Keeping $img uncompressed"
              else
                echo "‚ùå Over 1GB - compressing with XZ"
                echo "Compressing $img..."
                xz -9 -T 0 "$img"
                echo "Compressed $(basename "$img").xz"
              fi
              echo ""
            fi
          done
          
          echo "=== FINAL FILES ==="
          ls -lh

      - name: Sign release files with GPG
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/ISO'
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          cd ./isos/
          
          echo "üîê Signing release files with GPG..."
          
          # Import the private key
          echo "$GPG_PRIVATE_KEY" | gpg --batch --import
          
          # Get key ID for verification
          KEY_ID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5}' | head -1)
          echo "üìã Using GPG key: $KEY_ID"
          
          # Sign all release files
          for file in *.iso *.img *.xz; do
            if [ -f "$file" ]; then
              echo "üîè Signing: $file"
              
              # Create detached ASCII-armored signature
              gpg --batch --yes \
                  --pinentry-mode loopback \
                  --passphrase "$GPG_PASSPHRASE" \
                  --local-user "$KEY_ID" \
                  --detach-sign \
                  --armor \
                  --output "${file}.asc" \
                  "$file"
              
              if [ -f "${file}.asc" ]; then
                echo "‚úÖ Successfully signed: $file -> ${file}.asc"
                echo "üìù Signature size: $(wc -c < "${file}.asc") bytes"
              else
                echo "‚ùå Failed to sign: $file"
              fi
            fi
          done
          
          echo ""
          echo "=== SIGNED FILES ==="
          ls -lh *.asc 2>/dev/null || echo "No signature files found"
          
          echo ""
          echo "=== GPG KEY INFO ==="
          gpg --list-keys "$KEY_ID" || echo "Key info not available"

      - name: Generate release tag
        id: tag
        run: |
          TAG="v$(date +'%Y.%m.%d')-$(git rev-parse --short HEAD)"
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: LnOS Release ${{ steps.tag.outputs.tag }}
          body: |
            ## LnOS Custom Arch Linux Distribution
            
            ![GPG Signed](https://img.shields.io/badge/GPG-Signed-brightgreen?style=for-the-badge&logo=gnupg)
            ![Security Verified](https://img.shields.io/badge/Security-Verified-blue?style=for-the-badge&logo=shield)
            ![Integrity Guaranteed](https://img.shields.io/badge/Integrity-Guaranteed-orange?style=for-the-badge&logo=checkmarx)
            
            **üîí This release is cryptographically signed for authenticity and integrity**
            
            This release contains custom minimal Arch Linux images with the LnOS installer.
            
            ### Features:
            - **Cryptographically signed** with GPG (Key: `9486759312876AD7`)
            - Minimal Arch Linux base system
            - Interactive package selection
            - Desktop environment choices (GNOME, KDE, Hyprland, DWM, TTY)
            - CSE and Custom installation profiles
            - Automated partitioning and installation
            
            ### Files Included:
            - **x86_64 ISO/IMG**: For VMs, Intel/AMD computers, and USB boot
            - **ARM64 IMG**: SD card image for Raspberry Pi 4 and ARM64 devices
            - **Digital Signatures**: `.asc` files for verifying authenticity
            
            **Note**: Large files (>1GB) are compressed with XZ to stay under GitHub's 2GB limit. Files under 1GB are uncompressed and ready to use.
            
            ### üõ°Ô∏è Security & Digital Signature Verification:
            
            > ‚ö†Ô∏è **IMPORTANT**: Always verify file signatures before use! All release files are digitally signed with GPG.
            
            **GPG Key Information:**
            - **Key ID**: `9486759312876AD7`
            - **Fingerprint**: `FF3B 2203 9FA1 CBC0 72E5 8967 9486 7593 1287 6AD7`
            - **Owner**: LnOS Development Team
            
            **Verification Methods:**
            ```bash
            # Quick verification (auto-imports key)
            curl -fsSL https://raw.githubusercontent.com/uta-lug-nuts/LnOS/main/scripts/verify-signature.sh | bash -s -- <filename>
            
            # Manual verification
            curl -fsSL https://raw.githubusercontent.com/uta-lug-nuts/LnOS/main/keys/lnos-public-key.asc | gpg --import
            gpg --verify <filename>.asc <filename>
            ```
            
            ### Checksums:
            ```
            $(cd isos && sha256sum * 2>/dev/null || echo "Checksums will be calculated...")
            ```
          files: ./isos/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
